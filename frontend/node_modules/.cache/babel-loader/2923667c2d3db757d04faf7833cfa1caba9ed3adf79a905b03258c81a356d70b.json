{"ast":null,"code":"import{useEffect,useRef,useCallback}from'react';import{useVoiceStore}from'../stores/voiceStore';export const useVoiceChat=function(){let options=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};const{autoConnect=true,apiUrl='ws://localhost:8000/api/voice/stream'}=options;const websocketRef=useRef(null);const mediaRecorderRef=useRef(null);const audioChunksRef=useRef([]);const audioContextRef=useRef(null);const{isRecording,isProcessing,connectionStatus,error,setRecording,setProcessing,setConnectionStatus,setError,updateCurrentIntent,updateExtractedEntities,updateSuggestions,updateUrgencyLevel,processVoiceResponse}=useVoiceStore();// Connect to WebSocket\nconst connect=useCallback(()=>{var _websocketRef$current;if(((_websocketRef$current=websocketRef.current)===null||_websocketRef$current===void 0?void 0:_websocketRef$current.readyState)===WebSocket.OPEN){return;}setConnectionStatus('connecting');const ws=new WebSocket(apiUrl);ws.onopen=()=>{console.log('Connected to voice chat');setConnectionStatus('connected');};ws.onmessage=event=>{try{const response=JSON.parse(event.data);processVoiceResponse(response);if(response.audio_response){playAudioResponse(response.audio_response);}setProcessing(false);}catch(error){console.error('Error parsing WebSocket message:',error);setProcessing(false);}};ws.onerror=error=>{console.error('WebSocket error:',error);setConnectionStatus('error');setProcessing(false);};ws.onclose=()=>{console.log('Disconnected from voice chat');setConnectionStatus('disconnected');setProcessing(false);};websocketRef.current=ws;},[apiUrl,setConnectionStatus,processVoiceResponse,setProcessing]);// Start recording\nconst startRecording=useCallback(async()=>{try{const stream=await navigator.mediaDevices.getUserMedia({audio:{sampleRate:16000,channelCount:1,echoCancellation:true,noiseSuppression:true}});audioChunksRef.current=[];const mediaRecorder=new MediaRecorder(stream,{mimeType:'audio/webm'});mediaRecorder.ondataavailable=event=>{if(event.data.size>0){audioChunksRef.current.push(event.data);}};mediaRecorder.onstop=()=>{const audioBlob=new Blob(audioChunksRef.current,{type:'audio/webm'});sendAudioToServer(audioBlob);stream.getTracks().forEach(track=>track.stop());};mediaRecorderRef.current=mediaRecorder;mediaRecorder.start(100);setRecording(true);}catch(error){console.error('Error starting recording:',error);alert('Unable to access microphone. Please check permissions.');}},[setRecording]);// Stop recording\nconst stopRecording=useCallback(()=>{if(mediaRecorderRef.current&&isRecording){mediaRecorderRef.current.stop();setRecording(false);setProcessing(true);}},[isRecording,setRecording,setProcessing]);// Send audio to server\nconst sendAudioToServer=useCallback(async audioBlob=>{if(!websocketRef.current||websocketRef.current.readyState!==WebSocket.OPEN){console.error('WebSocket not connected');setProcessing(false);return;}try{const arrayBuffer=await audioBlob.arrayBuffer();const base64Audio=btoa(String.fromCharCode(...new Uint8Array(arrayBuffer)));websocketRef.current.send(JSON.stringify({type:'audio',audio:base64Audio}));}catch(error){console.error('Error sending audio:',error);setProcessing(false);}},[setProcessing]);// Play audio response\nconst playAudioResponse=useCallback(async base64Audio=>{try{if(!audioContextRef.current){audioContextRef.current=new(window.AudioContext||window.webkitAudioContext)();}const audioData=atob(base64Audio);const arrayBuffer=new ArrayBuffer(audioData.length);const view=new Uint8Array(arrayBuffer);for(let i=0;i<audioData.length;i++){view[i]=audioData.charCodeAt(i);}const audioBuffer=await audioContextRef.current.decodeAudioData(arrayBuffer);const source=audioContextRef.current.createBufferSource();source.buffer=audioBuffer;source.connect(audioContextRef.current.destination);source.start();}catch(error){console.error('Error playing audio:',error);}},[]);// Toggle recording\nconst toggleRecording=useCallback(()=>{if(isRecording){stopRecording();}else{startRecording();}},[isRecording,startRecording,stopRecording]);// Enhanced error handling and reconnection\nconst resetConnection=useCallback(()=>{if(websocketRef.current){websocketRef.current.close();websocketRef.current=null;}setError(undefined);setTimeout(()=>{connect();},1000);},[]);// Auto-connect on mount\nuseEffect(()=>{if(autoConnect){connect();}return()=>{if(websocketRef.current){websocketRef.current.close();}};},[autoConnect,connect]);return{connect,startRecording,stopRecording,toggleRecording,resetConnection,isRecording,isProcessing,connectionStatus,isConnected:connectionStatus==='connected',error};};","map":{"version":3,"names":["useEffect","useRef","useCallback","useVoiceStore","useVoiceChat","options","arguments","length","undefined","autoConnect","apiUrl","websocketRef","mediaRecorderRef","audioChunksRef","audioContextRef","isRecording","isProcessing","connectionStatus","error","setRecording","setProcessing","setConnectionStatus","setError","updateCurrentIntent","updateExtractedEntities","updateSuggestions","updateUrgencyLevel","processVoiceResponse","connect","_websocketRef$current","current","readyState","WebSocket","OPEN","ws","onopen","console","log","onmessage","event","response","JSON","parse","data","audio_response","playAudioResponse","onerror","onclose","startRecording","stream","navigator","mediaDevices","getUserMedia","audio","sampleRate","channelCount","echoCancellation","noiseSuppression","mediaRecorder","MediaRecorder","mimeType","ondataavailable","size","push","onstop","audioBlob","Blob","type","sendAudioToServer","getTracks","forEach","track","stop","start","alert","stopRecording","arrayBuffer","base64Audio","btoa","String","fromCharCode","Uint8Array","send","stringify","window","AudioContext","webkitAudioContext","audioData","atob","ArrayBuffer","view","i","charCodeAt","audioBuffer","decodeAudioData","source","createBufferSource","buffer","destination","toggleRecording","resetConnection","close","setTimeout","isConnected"],"sources":["D:/My projects/AI DOk/doc/frontend/src/hooks/useVoiceChat.ts"],"sourcesContent":["import { useEffect, useRef, useCallback } from 'react';\r\nimport { useVoiceStore } from '../stores/voiceStore';\r\nimport { VoiceResponse } from '../types';\r\n\r\ninterface UseVoiceChatOptions {\r\n  autoConnect?: boolean;\r\n  apiUrl?: string;\r\n}\r\n\r\nexport const useVoiceChat = (options: UseVoiceChatOptions = {}) => {\r\n  const {\r\n    autoConnect = true,\r\n    apiUrl = 'ws://localhost:8000/api/voice/stream'\r\n  } = options;\r\n\r\n  const websocketRef = useRef<WebSocket | null>(null);\r\n  const mediaRecorderRef = useRef<MediaRecorder | null>(null);\r\n  const audioChunksRef = useRef<Blob[]>([]);\r\n  const audioContextRef = useRef<AudioContext | null>(null);\r\n\r\n  const {\r\n    isRecording,\r\n    isProcessing,\r\n    connectionStatus,\r\n    error,\r\n    setRecording,\r\n    setProcessing,\r\n    setConnectionStatus,\r\n    setError,\r\n    updateCurrentIntent,\r\n    updateExtractedEntities,\r\n    updateSuggestions,\r\n    updateUrgencyLevel,\r\n    processVoiceResponse\r\n  } = useVoiceStore();\r\n\r\n  // Connect to WebSocket\r\n  const connect = useCallback(() => {\r\n    if (websocketRef.current?.readyState === WebSocket.OPEN) {\r\n      return;\r\n    }\r\n\r\n    setConnectionStatus('connecting');\r\n    \r\n    const ws = new WebSocket(apiUrl);\r\n    \r\n    ws.onopen = () => {\r\n      console.log('Connected to voice chat');\r\n      setConnectionStatus('connected');\r\n    };\r\n    \r\n    ws.onmessage = (event) => {\r\n      try {\r\n        const response: VoiceResponse = JSON.parse(event.data);\r\n        processVoiceResponse(response);\r\n        \r\n        if (response.audio_response) {\r\n          playAudioResponse(response.audio_response);\r\n        }\r\n        \r\n        setProcessing(false);\r\n      } catch (error) {\r\n        console.error('Error parsing WebSocket message:', error);\r\n        setProcessing(false);\r\n      }\r\n    };\r\n    \r\n    ws.onerror = (error) => {\r\n      console.error('WebSocket error:', error);\r\n      setConnectionStatus('error');\r\n      setProcessing(false);\r\n    };\r\n    \r\n    ws.onclose = () => {\r\n      console.log('Disconnected from voice chat');\r\n      setConnectionStatus('disconnected');\r\n      setProcessing(false);\r\n    };\r\n    \r\n    websocketRef.current = ws;\r\n  }, [apiUrl, setConnectionStatus, processVoiceResponse, setProcessing]);\r\n\r\n  // Start recording\r\n  const startRecording = useCallback(async () => {\r\n    try {\r\n      const stream = await navigator.mediaDevices.getUserMedia({ \r\n        audio: {\r\n          sampleRate: 16000,\r\n          channelCount: 1,\r\n          echoCancellation: true,\r\n          noiseSuppression: true\r\n        } \r\n      });\r\n      \r\n      audioChunksRef.current = [];\r\n      \r\n      const mediaRecorder = new MediaRecorder(stream, {\r\n        mimeType: 'audio/webm'\r\n      });\r\n      \r\n      mediaRecorder.ondataavailable = (event) => {\r\n        if (event.data.size > 0) {\r\n          audioChunksRef.current.push(event.data);\r\n        }\r\n      };\r\n      \r\n      mediaRecorder.onstop = () => {\r\n        const audioBlob = new Blob(audioChunksRef.current, { type: 'audio/webm' });\r\n        sendAudioToServer(audioBlob);\r\n        stream.getTracks().forEach(track => track.stop());\r\n      };\r\n      \r\n      mediaRecorderRef.current = mediaRecorder;\r\n      mediaRecorder.start(100);\r\n      setRecording(true);\r\n      \r\n    } catch (error) {\r\n      console.error('Error starting recording:', error);\r\n      alert('Unable to access microphone. Please check permissions.');\r\n    }\r\n  }, [setRecording]);\r\n\r\n  // Stop recording\r\n  const stopRecording = useCallback(() => {\r\n    if (mediaRecorderRef.current && isRecording) {\r\n      mediaRecorderRef.current.stop();\r\n      setRecording(false);\r\n      setProcessing(true);\r\n    }\r\n  }, [isRecording, setRecording, setProcessing]);\r\n\r\n  // Send audio to server\r\n  const sendAudioToServer = useCallback(async (audioBlob: Blob) => {\r\n    if (!websocketRef.current || websocketRef.current.readyState !== WebSocket.OPEN) {\r\n      console.error('WebSocket not connected');\r\n      setProcessing(false);\r\n      return;\r\n    }\r\n\r\n    try {\r\n      const arrayBuffer = await audioBlob.arrayBuffer();\r\n      const base64Audio = btoa(String.fromCharCode(...new Uint8Array(arrayBuffer)));\r\n      \r\n      websocketRef.current.send(JSON.stringify({\r\n        type: 'audio',\r\n        audio: base64Audio\r\n      }));\r\n      \r\n    } catch (error) {\r\n      console.error('Error sending audio:', error);\r\n      setProcessing(false);\r\n    }\r\n  }, [setProcessing]);\r\n\r\n  // Play audio response\r\n  const playAudioResponse = useCallback(async (base64Audio: string) => {\r\n    try {\r\n      if (!audioContextRef.current) {\r\n        audioContextRef.current = new (window.AudioContext || (window as any).webkitAudioContext)();\r\n      }\r\n      \r\n      const audioData = atob(base64Audio);\r\n      const arrayBuffer = new ArrayBuffer(audioData.length);\r\n      const view = new Uint8Array(arrayBuffer);\r\n      \r\n      for (let i = 0; i < audioData.length; i++) {\r\n        view[i] = audioData.charCodeAt(i);\r\n      }\r\n      \r\n      const audioBuffer = await audioContextRef.current.decodeAudioData(arrayBuffer);\r\n      const source = audioContextRef.current.createBufferSource();\r\n      source.buffer = audioBuffer;\r\n      source.connect(audioContextRef.current.destination);\r\n      source.start();\r\n      \r\n    } catch (error) {\r\n      console.error('Error playing audio:', error);\r\n    }\r\n  }, []);\r\n\r\n  // Toggle recording\r\n  const toggleRecording = useCallback(() => {\r\n    if (isRecording) {\r\n      stopRecording();\r\n    } else {\r\n      startRecording();\r\n    }\r\n  }, [isRecording, startRecording, stopRecording]);\r\n\r\n  // Enhanced error handling and reconnection\r\n  const resetConnection = useCallback(() => {\r\n    if (websocketRef.current) {\r\n      websocketRef.current.close();\r\n      websocketRef.current = null;\r\n    }\r\n    setError(undefined);\r\n    setTimeout(() => {\r\n      connect();\r\n    }, 1000);\r\n  }, []);\r\n\r\n  // Auto-connect on mount\r\n  useEffect(() => {\r\n    if (autoConnect) {\r\n      connect();\r\n    }\r\n    \r\n    return () => {\r\n      if (websocketRef.current) {\r\n        websocketRef.current.close();\r\n      }\r\n    };\r\n  }, [autoConnect, connect]);\r\n\r\n  return {\r\n    connect,\r\n    startRecording,\r\n    stopRecording,\r\n    toggleRecording,\r\n    resetConnection,\r\n    isRecording,\r\n    isProcessing,\r\n    connectionStatus,\r\n    isConnected: connectionStatus === 'connected',\r\n    error\r\n  };\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}