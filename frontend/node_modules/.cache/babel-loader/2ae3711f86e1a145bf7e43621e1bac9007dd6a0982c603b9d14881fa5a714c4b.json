{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useEffect, useRef, useCallback } from 'react';\nimport { useVoiceStore } from '../stores/voiceStore';\nexport const useVoiceChat = (options = {}) => {\n  _s();\n  const {\n    autoConnect = true,\n    apiUrl = 'ws://localhost:8000/api/voice/stream'\n  } = options;\n  const websocketRef = useRef(null);\n  const mediaRecorderRef = useRef(null);\n  const audioChunksRef = useRef([]);\n  const audioContextRef = useRef(null);\n  const {\n    isRecording,\n    isProcessing,\n    connectionStatus,\n    error,\n    setRecording,\n    setProcessing,\n    setConnectionStatus,\n    setError,\n    updateCurrentIntent,\n    updateExtractedEntities,\n    updateSuggestions,\n    updateUrgencyLevel,\n    processVoiceResponse\n  } = useVoiceStore();\n\n  // Connect to WebSocket\n  const connect = useCallback(() => {\n    var _websocketRef$current;\n    if (((_websocketRef$current = websocketRef.current) === null || _websocketRef$current === void 0 ? void 0 : _websocketRef$current.readyState) === WebSocket.OPEN) {\n      return;\n    }\n    setConnectionStatus('connecting');\n    const ws = new WebSocket(apiUrl);\n    ws.onopen = () => {\n      console.log('Connected to voice chat');\n      setConnectionStatus('connected');\n    };\n    ws.onmessage = event => {\n      try {\n        const response = JSON.parse(event.data);\n        processVoiceResponse(response);\n        if (response.audio_response) {\n          playAudioResponse(response.audio_response);\n        }\n        setProcessing(false);\n      } catch (error) {\n        console.error('Error parsing WebSocket message:', error);\n        setProcessing(false);\n      }\n    };\n    ws.onerror = error => {\n      console.error('WebSocket error:', error);\n      setConnectionStatus('error');\n      setProcessing(false);\n    };\n    ws.onclose = () => {\n      console.log('Disconnected from voice chat');\n      setConnectionStatus('disconnected');\n      setProcessing(false);\n    };\n    websocketRef.current = ws;\n  }, [apiUrl, setConnectionStatus, processVoiceResponse, setProcessing]);\n\n  // Start recording\n  const startRecording = useCallback(async () => {\n    try {\n      const stream = await navigator.mediaDevices.getUserMedia({\n        audio: {\n          sampleRate: 16000,\n          channelCount: 1,\n          echoCancellation: true,\n          noiseSuppression: true\n        }\n      });\n      audioChunksRef.current = [];\n      const mediaRecorder = new MediaRecorder(stream, {\n        mimeType: 'audio/webm'\n      });\n      mediaRecorder.ondataavailable = event => {\n        if (event.data.size > 0) {\n          audioChunksRef.current.push(event.data);\n        }\n      };\n      mediaRecorder.onstop = () => {\n        const audioBlob = new Blob(audioChunksRef.current, {\n          type: 'audio/webm'\n        });\n        sendAudioToServer(audioBlob);\n        stream.getTracks().forEach(track => track.stop());\n      };\n      mediaRecorderRef.current = mediaRecorder;\n      mediaRecorder.start(100);\n      setRecording(true);\n    } catch (error) {\n      console.error('Error starting recording:', error);\n      alert('Unable to access microphone. Please check permissions.');\n    }\n  }, [setRecording]);\n\n  // Stop recording\n  const stopRecording = useCallback(() => {\n    if (mediaRecorderRef.current && isRecording) {\n      mediaRecorderRef.current.stop();\n      setRecording(false);\n      setProcessing(true);\n    }\n  }, [isRecording, setRecording, setProcessing]);\n\n  // Send audio to server\n  const sendAudioToServer = useCallback(async audioBlob => {\n    if (!websocketRef.current || websocketRef.current.readyState !== WebSocket.OPEN) {\n      console.error('WebSocket not connected');\n      setProcessing(false);\n      return;\n    }\n    try {\n      const arrayBuffer = await audioBlob.arrayBuffer();\n      const base64Audio = btoa(String.fromCharCode(...new Uint8Array(arrayBuffer)));\n      websocketRef.current.send(JSON.stringify({\n        type: 'audio',\n        audio: base64Audio\n      }));\n    } catch (error) {\n      console.error('Error sending audio:', error);\n      setProcessing(false);\n    }\n  }, [setProcessing]);\n\n  // Play audio response\n  const playAudioResponse = useCallback(async base64Audio => {\n    try {\n      if (!audioContextRef.current) {\n        audioContextRef.current = new (window.AudioContext || window.webkitAudioContext)();\n      }\n      const audioData = atob(base64Audio);\n      const arrayBuffer = new ArrayBuffer(audioData.length);\n      const view = new Uint8Array(arrayBuffer);\n      for (let i = 0; i < audioData.length; i++) {\n        view[i] = audioData.charCodeAt(i);\n      }\n      const audioBuffer = await audioContextRef.current.decodeAudioData(arrayBuffer);\n      const source = audioContextRef.current.createBufferSource();\n      source.buffer = audioBuffer;\n      source.connect(audioContextRef.current.destination);\n      source.start();\n    } catch (error) {\n      console.error('Error playing audio:', error);\n    }\n  }, []);\n\n  // Toggle recording\n  const toggleRecording = useCallback(() => {\n    if (isRecording) {\n      stopRecording();\n    } else {\n      startRecording();\n    }\n  }, [isRecording, startRecording, stopRecording]);\n\n  // Enhanced error handling and reconnection\n  const resetConnection = useCallback(() => {\n    if (websocketRef.current) {\n      websocketRef.current.close();\n      websocketRef.current = null;\n    }\n    setError(undefined);\n    setTimeout(() => {\n      connect();\n    }, 1000);\n  }, []);\n\n  // Auto-connect on mount\n  useEffect(() => {\n    if (autoConnect) {\n      connect();\n    }\n    return () => {\n      if (websocketRef.current) {\n        websocketRef.current.close();\n      }\n    };\n  }, [autoConnect, connect]);\n  return {\n    connect,\n    startRecording,\n    stopRecording,\n    toggleRecording,\n    isRecording,\n    isProcessing,\n    connectionStatus,\n    isConnected: connectionStatus === 'connected'\n  };\n};\n_s(useVoiceChat, \"7VaknAi2q/DGYzLQT8HtgaE5ZxI=\", false, function () {\n  return [useVoiceStore];\n});","map":{"version":3,"names":["useEffect","useRef","useCallback","useVoiceStore","useVoiceChat","options","_s","autoConnect","apiUrl","websocketRef","mediaRecorderRef","audioChunksRef","audioContextRef","isRecording","isProcessing","connectionStatus","error","setRecording","setProcessing","setConnectionStatus","setError","updateCurrentIntent","updateExtractedEntities","updateSuggestions","updateUrgencyLevel","processVoiceResponse","connect","_websocketRef$current","current","readyState","WebSocket","OPEN","ws","onopen","console","log","onmessage","event","response","JSON","parse","data","audio_response","playAudioResponse","onerror","onclose","startRecording","stream","navigator","mediaDevices","getUserMedia","audio","sampleRate","channelCount","echoCancellation","noiseSuppression","mediaRecorder","MediaRecorder","mimeType","ondataavailable","size","push","onstop","audioBlob","Blob","type","sendAudioToServer","getTracks","forEach","track","stop","start","alert","stopRecording","arrayBuffer","base64Audio","btoa","String","fromCharCode","Uint8Array","send","stringify","window","AudioContext","webkitAudioContext","audioData","atob","ArrayBuffer","length","view","i","charCodeAt","audioBuffer","decodeAudioData","source","createBufferSource","buffer","destination","toggleRecording","resetConnection","close","undefined","setTimeout","isConnected"],"sources":["D:/My projects/AI DOk/doc/frontend/src/hooks/useVoiceChat.ts"],"sourcesContent":["import { useEffect, useRef, useCallback } from 'react';\r\nimport { useVoiceStore } from '../stores/voiceStore';\r\nimport { VoiceResponse } from '../types';\r\n\r\ninterface UseVoiceChatOptions {\r\n  autoConnect?: boolean;\r\n  apiUrl?: string;\r\n}\r\n\r\nexport const useVoiceChat = (options: UseVoiceChatOptions = {}) => {\r\n  const {\r\n    autoConnect = true,\r\n    apiUrl = 'ws://localhost:8000/api/voice/stream'\r\n  } = options;\r\n\r\n  const websocketRef = useRef<WebSocket | null>(null);\r\n  const mediaRecorderRef = useRef<MediaRecorder | null>(null);\r\n  const audioChunksRef = useRef<Blob[]>([]);\r\n  const audioContextRef = useRef<AudioContext | null>(null);\r\n\r\n  const {\r\n    isRecording,\r\n    isProcessing,\r\n    connectionStatus,\r\n    error,\r\n    setRecording,\r\n    setProcessing,\r\n    setConnectionStatus,\r\n    setError,\r\n    updateCurrentIntent,\r\n    updateExtractedEntities,\r\n    updateSuggestions,\r\n    updateUrgencyLevel,\r\n    processVoiceResponse\r\n  } = useVoiceStore();\r\n\r\n  // Connect to WebSocket\r\n  const connect = useCallback(() => {\r\n    if (websocketRef.current?.readyState === WebSocket.OPEN) {\r\n      return;\r\n    }\r\n\r\n    setConnectionStatus('connecting');\r\n    \r\n    const ws = new WebSocket(apiUrl);\r\n    \r\n    ws.onopen = () => {\r\n      console.log('Connected to voice chat');\r\n      setConnectionStatus('connected');\r\n    };\r\n    \r\n    ws.onmessage = (event) => {\r\n      try {\r\n        const response: VoiceResponse = JSON.parse(event.data);\r\n        processVoiceResponse(response);\r\n        \r\n        if (response.audio_response) {\r\n          playAudioResponse(response.audio_response);\r\n        }\r\n        \r\n        setProcessing(false);\r\n      } catch (error) {\r\n        console.error('Error parsing WebSocket message:', error);\r\n        setProcessing(false);\r\n      }\r\n    };\r\n    \r\n    ws.onerror = (error) => {\r\n      console.error('WebSocket error:', error);\r\n      setConnectionStatus('error');\r\n      setProcessing(false);\r\n    };\r\n    \r\n    ws.onclose = () => {\r\n      console.log('Disconnected from voice chat');\r\n      setConnectionStatus('disconnected');\r\n      setProcessing(false);\r\n    };\r\n    \r\n    websocketRef.current = ws;\r\n  }, [apiUrl, setConnectionStatus, processVoiceResponse, setProcessing]);\r\n\r\n  // Start recording\r\n  const startRecording = useCallback(async () => {\r\n    try {\r\n      const stream = await navigator.mediaDevices.getUserMedia({ \r\n        audio: {\r\n          sampleRate: 16000,\r\n          channelCount: 1,\r\n          echoCancellation: true,\r\n          noiseSuppression: true\r\n        } \r\n      });\r\n      \r\n      audioChunksRef.current = [];\r\n      \r\n      const mediaRecorder = new MediaRecorder(stream, {\r\n        mimeType: 'audio/webm'\r\n      });\r\n      \r\n      mediaRecorder.ondataavailable = (event) => {\r\n        if (event.data.size > 0) {\r\n          audioChunksRef.current.push(event.data);\r\n        }\r\n      };\r\n      \r\n      mediaRecorder.onstop = () => {\r\n        const audioBlob = new Blob(audioChunksRef.current, { type: 'audio/webm' });\r\n        sendAudioToServer(audioBlob);\r\n        stream.getTracks().forEach(track => track.stop());\r\n      };\r\n      \r\n      mediaRecorderRef.current = mediaRecorder;\r\n      mediaRecorder.start(100);\r\n      setRecording(true);\r\n      \r\n    } catch (error) {\r\n      console.error('Error starting recording:', error);\r\n      alert('Unable to access microphone. Please check permissions.');\r\n    }\r\n  }, [setRecording]);\r\n\r\n  // Stop recording\r\n  const stopRecording = useCallback(() => {\r\n    if (mediaRecorderRef.current && isRecording) {\r\n      mediaRecorderRef.current.stop();\r\n      setRecording(false);\r\n      setProcessing(true);\r\n    }\r\n  }, [isRecording, setRecording, setProcessing]);\r\n\r\n  // Send audio to server\r\n  const sendAudioToServer = useCallback(async (audioBlob: Blob) => {\r\n    if (!websocketRef.current || websocketRef.current.readyState !== WebSocket.OPEN) {\r\n      console.error('WebSocket not connected');\r\n      setProcessing(false);\r\n      return;\r\n    }\r\n\r\n    try {\r\n      const arrayBuffer = await audioBlob.arrayBuffer();\r\n      const base64Audio = btoa(String.fromCharCode(...new Uint8Array(arrayBuffer)));\r\n      \r\n      websocketRef.current.send(JSON.stringify({\r\n        type: 'audio',\r\n        audio: base64Audio\r\n      }));\r\n      \r\n    } catch (error) {\r\n      console.error('Error sending audio:', error);\r\n      setProcessing(false);\r\n    }\r\n  }, [setProcessing]);\r\n\r\n  // Play audio response\r\n  const playAudioResponse = useCallback(async (base64Audio: string) => {\r\n    try {\r\n      if (!audioContextRef.current) {\r\n        audioContextRef.current = new (window.AudioContext || (window as any).webkitAudioContext)();\r\n      }\r\n      \r\n      const audioData = atob(base64Audio);\r\n      const arrayBuffer = new ArrayBuffer(audioData.length);\r\n      const view = new Uint8Array(arrayBuffer);\r\n      \r\n      for (let i = 0; i < audioData.length; i++) {\r\n        view[i] = audioData.charCodeAt(i);\r\n      }\r\n      \r\n      const audioBuffer = await audioContextRef.current.decodeAudioData(arrayBuffer);\r\n      const source = audioContextRef.current.createBufferSource();\r\n      source.buffer = audioBuffer;\r\n      source.connect(audioContextRef.current.destination);\r\n      source.start();\r\n      \r\n    } catch (error) {\r\n      console.error('Error playing audio:', error);\r\n    }\r\n  }, []);\r\n\r\n  // Toggle recording\r\n  const toggleRecording = useCallback(() => {\r\n    if (isRecording) {\r\n      stopRecording();\r\n    } else {\r\n      startRecording();\r\n    }\r\n  }, [isRecording, startRecording, stopRecording]);\r\n\r\n  // Enhanced error handling and reconnection\r\n  const resetConnection = useCallback(() => {\r\n    if (websocketRef.current) {\r\n      websocketRef.current.close();\r\n      websocketRef.current = null;\r\n    }\r\n    setError(undefined);\r\n    setTimeout(() => {\r\n      connect();\r\n    }, 1000);\r\n  }, []);\r\n\r\n  // Auto-connect on mount\r\n  useEffect(() => {\r\n    if (autoConnect) {\r\n      connect();\r\n    }\r\n    \r\n    return () => {\r\n      if (websocketRef.current) {\r\n        websocketRef.current.close();\r\n      }\r\n    };\r\n  }, [autoConnect, connect]);\r\n\r\n  return {\r\n    connect,\r\n    startRecording,\r\n    stopRecording,\r\n    toggleRecording,\r\n    isRecording,\r\n    isProcessing,\r\n    connectionStatus,\r\n    isConnected: connectionStatus === 'connected'\r\n  };\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}